---
title: "Analisis_generico"
output: html_document
---
# Definir directorio de trabajo

Aqui probablemente el codigo te dara problemas, porque queremos definir como directorio de trabajo la carpeta de COPLAS porque los archivos estan ahi. Como este Markdown esta dentro de un Proyecto con su carpeta asociada, R entiende que el directorio es ese (".../Instar/implementaciones/instar_baza/scripts/git_Instar_baza"). Estrictamente hablando deberiamos escribir el codigo de manera que cuando llamemos a un archivo le demos el path apropiado ("...\Instar\calibracion_validacion\fuentes_datos_validacion\COPLAS_PLAGAS"). Pero tambien se puede definir el directorio de manera manual (Session > Set Working Directory > Choose Directory), y asi R si acepta que sea una carpeta distinta a donde esta el proyecto. Por mi las dos opciones valen, la que te sea mas facil :)

He definido el WD de manera manual. 
Definir como directorio la carpeta COPLAS_PLAGAS
# Cargar paquetes
```{r}
#install.packages("lubridate")
library(lubridate) # Para las fechas
```

# DATOS INSTAR

## Importar datos INSTAR 

- La tabla de datos se construye en excel y se guarda como .csv
- Se abre con procesador de texto, y se comprueba que la fecha está en formato mm-dd-yy
- Se guarda como .txt
 Las columnas que constituyen la tabla son: fecha, huevo, L1, L2, crisalida, radiacion, tmax, tmin, tmed y exergia.


TOMAMOS EL RODAL GR-023-008 (Sierra de Baza) COMO EJEMPLO
```{r}
INSTAR<-read.table("instar_bz008.txt", header=T, sep=",", dec=".")
INSTAR$fecha <-as.Date(INSTAR$fecha, format="%m-%d-%y")#aunque pongo formato mm/dd/yyyy se pone como yyyy-mm-dd
```

## Anadir biociclos al data.frame
```{r}
INSTAR$yday <- yday(INSTAR$fecha) # anadimos el dia del anio con el paquete lubridate
INSTAR$year <- year(INSTAR$fecha) # anadimos el anio con el paquete lubridate
INSTAR$biociclo <- NULL
#write.csv(INSTAR, file = "datos_instar_bz008.csv", row.names=FALSE, na="")
```

Aparece dos chunks para este proceso, uno para Baza y otro para Sierra Nevada, ya que tienen fechas de inicio diferentes. 

```{r}
#Baza
subset_1993 <- subset(INSTAR, INSTAR$year==1993)
for(i in 1:length(subset_1993$yday)){
  ifelse(subset_1993$yday[i]<=79, 
       subset_1993$biociclo[i] <- 1, subset_1993$biociclo[i] <- 2)
}

subset_1994 <- subset(INSTAR, INSTAR$year==1994)
for(i in 1:length(subset_1994$yday)){
  ifelse(subset_1994$yday[i]<=79, 
       subset_1994$biociclo[i] <- 2, subset_1994$biociclo[i] <- 3)
}

subset_1995 <- subset(INSTAR, INSTAR$year==1995)
for(i in 1:length(subset_1995$yday)){
  ifelse(subset_1995$yday[i]<=79, 
       subset_1995$biociclo[i] <- 3, subset_1995$biociclo[i] <- 4)
}

subset_1996 <- subset(INSTAR, INSTAR$year==1996)
for(i in 1:length(subset_1996$yday)){
  ifelse(subset_1996$yday[i]<=79, 
       subset_1996$biociclo[i] <- 4, subset_1996$biociclo[i] <- 5)
}

subset_1997 <- subset(INSTAR, INSTAR$year==1997)
for(i in 1:length(subset_1997$yday)){
  ifelse(subset_1997$yday[i]<=79, 
       subset_1997$biociclo[i] <- 5, subset_1997$biociclo[i] <- 6)
}

subset_1998 <- subset(INSTAR, INSTAR$year==1998)
for(i in 1:length(subset_1998$yday)){
  ifelse(subset_1998$yday[i]<=79, 
       subset_1998$biociclo[i] <- 6, subset_1998$biociclo[i] <- 7)
}

subset_1999 <- subset(INSTAR, INSTAR$year==1999)
for(i in 1:length(subset_1999$yday)){
  ifelse(subset_1999$yday[i]<=79, 
       subset_1999$biociclo[i] <- 7, subset_1999$biociclo[i] <- 8)
}

subset_2000 <- subset(INSTAR, INSTAR$year==2000)
for(i in 1:length(subset_2000$yday)){
  ifelse(subset_2000$yday[i]<=79, 
       subset_2000$biociclo[i] <- 8, subset_2000$biociclo[i] <- 9)
}

subset_2001 <- subset(INSTAR, INSTAR$year==2001)
for(i in 1:length(subset_2001$yday)){
  ifelse(subset_2001$yday[i]<=79, 
       subset_2001$biociclo[i] <- 9, subset_2001$biociclo[i] <- 10)
}

subset_2002 <- subset(INSTAR, INSTAR$year==2002)
for(i in 1:length(subset_2002$yday)){
  ifelse(subset_2002$yday[i]<=79, 
       subset_2002$biociclo[i] <- 10, subset_2002$biociclo[i] <- 11)
}

subset_2003 <- subset(INSTAR, INSTAR$year==2003)
for(i in 1:length(subset_2003$yday)){
  ifelse(subset_2003$yday[i]<=79, 
       subset_2003$biociclo[i] <- 11, subset_2003$biociclo[i] <- 12)
}

subset_2004 <- subset(INSTAR, INSTAR$year==2004)
for(i in 1:length(subset_2004$yday)){
  ifelse(subset_2004$yday[i]<=79, 
       subset_2004$biociclo[i] <- 12, subset_2004$biociclo[i] <- 13)
}
subset_2005 <- subset(INSTAR, INSTAR$year==2005)
for(i in 1:length(subset_2005$yday)){
  ifelse(subset_2005$yday[i]<=79, 
       subset_2005$biociclo[i] <- 13, subset_2005$biociclo[i] <- 14)
}

subset_2006 <- subset(INSTAR, INSTAR$year==2006)
for(i in 1:length(subset_2006$yday)){
  ifelse(subset_2006$yday[i]<=79, 
       subset_2006$biociclo[i] <- 14, subset_2006$biociclo[i] <- 15)
}

subset_2007 <- subset(INSTAR, INSTAR$year==2007)
for(i in 1:length(subset_2007$yday)){
  ifelse(subset_2007$yday[i]<=79, 
       subset_2007$biociclo[i] <- 15, subset_2007$biociclo[i] <- 16)
}

subset_2008 <- subset(INSTAR, INSTAR$year==2008)
for(i in 1:length(subset_2008$yday)){
  ifelse(subset_2008$yday[i]<=79, 
       subset_2008$biociclo[i] <- 16, subset_2008$biociclo[i] <- 17)
}

subset_2009 <- subset(INSTAR, INSTAR$year==2009)
for(i in 1:length(subset_2009$yday)){
  ifelse(subset_2009$yday[i]<=79, 
       subset_2009$biociclo[i] <- 17, subset_2009$biociclo[i] <- 18)
}

subset_2010 <- subset(INSTAR, INSTAR$year==2010)
for(i in 1:length(subset_2010$yday)){
  ifelse(subset_2010$yday[i]<=79, 
       subset_2010$biociclo[i] <- 18, subset_2010$biociclo[i] <- 19)
}

subset_2011 <- subset(INSTAR, INSTAR$year==2011)
for(i in 1:length(subset_2011$yday)){
  ifelse(subset_2011$yday[i]<=79, 
       subset_2011$biociclo[i] <- 19, subset_2011$biociclo[i] <- 20)
}

subset_2012 <- subset(INSTAR, INSTAR$year==2012)
for(i in 1:length(subset_2012$yday)){
  ifelse(subset_2012$yday[i]<=79, 
       subset_2012$biociclo[i] <- 20, subset_2012$biociclo[i] <- 21)
}

subset_2013 <- subset(INSTAR, INSTAR$year==2013)
for(i in 1:length(subset_2013$yday)){
  ifelse(subset_2013$yday[i]<=79, 
       subset_2013$biociclo[i] <- 21, subset_2013$biociclo[i] <- 22)
}

subset_2014 <- subset(INSTAR, INSTAR$year==2014)
for(i in 1:length(subset_2014$yday)){
  ifelse(subset_2014$yday[i]<=79, 
       subset_2014$biociclo[i] <- 22, subset_2014$biociclo[i] <- 23)
}

INSTAR<- rbind(subset_1994, subset_1995, subset_1996, subset_1997, subset_1998, subset_1999, subset_2000, subset_2001, subset_2002, subset_2003, subset_2004, subset_2005, subset_2006, subset_2007, subset_2008, subset_2009, subset_2010, subset_2011, subset_2012, subset_2013, subset_2014) #Se quitan el primer y ultimo biociclo porque no estan completos

#QUITAR BIOCICLO 2 y 23(incompletos)
INSTAR<-INSTAR[!(INSTAR$biociclo=="2"),]
INSTAR<-INSTAR[!(INSTAR$biociclo=="23"),]

```

```{r}
#Sierra Nevada
subset_2001 <- subset(INSTAR, INSTAR$year==2001)
for(i in 1:length(subset_2001$yday)){
  ifelse(subset_2001$yday[i]<=79, 
       subset_2001$biociclo[i] <- 1, subset_2001$biociclo[i] <- 2)
}

subset_2002 <- subset(INSTAR, INSTAR$year==2002)
for(i in 1:length(subset_2002$yday)){
  ifelse(subset_2002$yday[i]<=79, 
       subset_2002$biociclo[i] <- 2, subset_2002$biociclo[i] <- 3)
}

subset_2003 <- subset(INSTAR, INSTAR$year==2003)
for(i in 1:length(subset_2003$yday)){
  ifelse(subset_2003$yday[i]<=79, 
       subset_2003$biociclo[i] <- 3, subset_2003$biociclo[i] <- 4)
}

subset_2004 <- subset(INSTAR, INSTAR$year==2004)
for(i in 1:length(subset_2004$yday)){
  ifelse(subset_2004$yday[i]<=79, 
       subset_2004$biociclo[i] <- 4, subset_2004$biociclo[i] <- 5)
}
subset_2005 <- subset(INSTAR, INSTAR$year==2005)
for(i in 1:length(subset_2005$yday)){
  ifelse(subset_2005$yday[i]<=79, 
       subset_2005$biociclo[i] <- 5, subset_2005$biociclo[i] <- 6)
}

subset_2006 <- subset(INSTAR, INSTAR$year==2006)
for(i in 1:length(subset_2006$yday)){
  ifelse(subset_2006$yday[i]<=79, 
       subset_2006$biociclo[i] <- 6, subset_2006$biociclo[i] <- 7)
}

subset_2007 <- subset(INSTAR, INSTAR$year==2007)
for(i in 1:length(subset_2007$yday)){
  ifelse(subset_2007$yday[i]<=79, 
       subset_2007$biociclo[i] <- 7, subset_2007$biociclo[i] <- 8)
}

subset_2008 <- subset(INSTAR, INSTAR$year==2008)
for(i in 1:length(subset_2008$yday)){
  ifelse(subset_2008$yday[i]<=79, 
       subset_2008$biociclo[i] <- 8, subset_2008$biociclo[i] <- 9)
}

subset_2009 <- subset(INSTAR, INSTAR$year==2009)
for(i in 1:length(subset_2009$yday)){
  ifelse(subset_2009$yday[i]<=79, 
       subset_2009$biociclo[i] <- 9, subset_2009$biociclo[i] <- 10)
}

subset_2010 <- subset(INSTAR, INSTAR$year==2010)
for(i in 1:length(subset_2010$yday)){
  ifelse(subset_2010$yday[i]<=79, 
       subset_2010$biociclo[i] <- 10, subset_2010$biociclo[i] <- 11)
}

subset_2011 <- subset(INSTAR, INSTAR$year==2011)
for(i in 1:length(subset_2011$yday)){
  ifelse(subset_2011$yday[i]<=79, 
       subset_2011$biociclo[i] <- 11, subset_2011$biociclo[i] <- 12)
}

subset_2012 <- subset(INSTAR, INSTAR$year==2012)
for(i in 1:length(subset_2012$yday)){
  ifelse(subset_2012$yday[i]<=79, 
       subset_2012$biociclo[i] <- 12, subset_2012$biociclo[i] <- 13)
}

subset_2013 <- subset(INSTAR, INSTAR$year==2013)
for(i in 1:length(subset_2013$yday)){
  ifelse(subset_2013$yday[i]<=79, 
       subset_2013$biociclo[i] <- 13, subset_2013$biociclo[i] <- 14)
}

subset_2014 <- subset(INSTAR, INSTAR$year==2014)
for(i in 1:length(subset_2014$yday)){
  ifelse(subset_2014$yday[i]<=79, 
       subset_2014$biociclo[i] <- 14, subset_2014$biociclo[i] <- 15)
}

INSTAR<- rbind(subset_2002, subset_2003, subset_2004, subset_2005, subset_2006, subset_2007, subset_2008, subset_2009, subset_2010, subset_2011, subset_2012, subset_2013)
```

## Agregacion INSTAR

Media del vigor y sumas (l1, l2 y l1+l2) por biociclo

```{r}
sum_l1<- aggregate(x = INSTAR$L1, by=list(biociclo=INSTAR$biociclo), FUN=sum, na.rm=TRUE)
names(sum_l1)[2] <- "sum_l1"

sum_l2<- aggregate(x = INSTAR$L2, by=list(biociclo=INSTAR$biociclo), FUN=sum, na.rm=TRUE)
names(sum_l2)[2] <- "sum_l2"

larvas<-cbind(sum_l1, sum_l2)
larvas<-larvas[-c(3)]
larvas$sum_l1l2=larvas[,2]+larvas[,3]

sum_huevo<- aggregate(x = INSTAR$huevo, by=list(biociclo=INSTAR$biociclo), FUN=sum, na.rm=TRUE)
names(sum_huevo)[2] <- "sum_huevo"

sum_crisalida<- aggregate(x = INSTAR$crisalida, by=list(biociclo=INSTAR$biociclo), FUN=sum, na.rm=TRUE)
names(sum_crisalida)[2] <- "sum_crisalida"

avg_exergia<-aggregate(INSTAR$exergia, by=list(biociclo=INSTAR$biociclo), FUN=mean, na.rm=TRUE)
names(avg_exergia)[2] <- "avg_exergia"



agreg_INSTAR <- cbind(larvas,avg_exergia, sum_crisalida, sum_huevo)
agreg_INSTAR_biociclo <- agreg_INSTAR[ -c(5, 7, 9) ]

#write.csv(agreg_INSTAR_biociclo,"agreg_INSTAR_bz008_biociclo.csv",row.names=FALSE, na="")
```

## Ln INSTAR (l1, l2 y l1+l2)
*Update: En la reunión del 9 de septiembre se llegó a la conclusión de que no era necesario transformar las variables. 

Se agrega una columna a la tabla 'Agreg_INSTAR_xxxxx_biociclo' con el resultado del Ln de cada columna referente a Larvas (sum_l1, sum_l2, sum_l1l2)
```{r, eval=FALSE, include=FALSE}
agreg_INSTAR_biociclo$l1_ln<-with(agreg_INSTAR_biociclo, log(sum_l1))
agreg_INSTAR_biociclo$l2_ln<-with(agreg_INSTAR_biociclo, log(sum_l2))
agreg_INSTAR_biociclo$l1l2_ln<-with(agreg_INSTAR_biociclo, log(sum_l1l2))
```

# DATOS COPLAS

## Importar datos COPLAS 

```{r}
COPLAS<-read.csv("zona_baza.csv", header=TRUE, sep=",")
names(COPLAS)[1] <- "RODAL"
```

Llamamos a cada rodal como los tres ultimos numeros de su codigo GRxxxxxx
Activar el rodal necesario para el análisis. 
```{r}
#rodal<-subset(COPLAS, RODAL == "GR000006")
rodal<-subset(COPLAS, RODAL == "GR023008")
#rodal<-subset(COPLAS, RODAL == "GR023012")
#rodal<-subset(COPLAS, RODAL == "GR023015")
#rodal<-subset(COPLAS, RODAL == "GR023017")
#rodal<-subset(COPLAS, RODAL == "GR023021")

#rodal<-subset(COPLAS, RODAL == "GR000030")
#rodal<-subset(COPLAS, RODAL == "GR134018")
#rodal<-subset(COPLAS, RODAL == "GR134020")
#rodal<-subset(COPLAS, RODAL == "GR134021")

#Eliminar primer y ultimo año porque en Instar no teneos datos de ese año completo. 
rodal<-rodal[-c(1,2, 23),]
```

## Definir biociclo COPLAS (opcional)
```{r}
rodal$biociclo <- 3:22 #Sierra de Baza
#rodal$biociclo <- 1:15 #Sierra Nevada
```

##Crear una tabla unica en la que tengamos los datos agregados de Instar y los datos de COPLAS
En esta tabla aparecen los datos de Instar agregados, los Ln de sumL1, sumL2 y sumL1+sumL2, el anio y el grado de infestacion de COPLAS. 
```{r}
COPLAS_INSTAR<-merge.data.frame(agreg_INSTAR_biociclo, rodal, by.x = "biociclo")
COPLAS_INSTAR<-COPLAS_INSTAR[-c(8)] #Eliminar la columna con el nombre del rodal
```


# VALIDACION EXTERNA

```{r}
library(graphics)
library(ggplot2)
```

## glm [avg_exergia, sum_l1, sum_l2, sum_l1l2 vs COPLAS]

*Se realizara, finalmente, GLM que analicen la relacion entre las variables de Instar (Exergia, sumL1, sumL2 y sumL1L2) y COPLAS. 
La distribución es de Poisson.*

Una alternativa a la transformacion de la variable respuesta y a la falta de normalidad es el uso de los modelos linales generalizados. Los GLM son una extension de los modelos lineales que permiten utilizar distribuciones no normales de lso errores (Poisson, como en este caso) y varianzas no constantes.

Los modelos Poisoon se utilizan generalmente para representar datos de conteo. El uso de modelos lineales no sería adecuado ante datos de conteo por las siguientes razones:
- El modelo lineal podría predecir valores negativos de la variable respuesta.
- La varianza de la variable respuesta aumnetara probablemente a medida que aumenta la media (varianza no constante).
- Los errores no estan normalmente distribuidos.
- Los ceros son dificiles de manejar en transformaciones de la variable respuesta. 

Comprobar dispersion. ¿Como se hace? "Overdispersed Poisson occurs when sd >> mean"

###Asunciones y modelo de regresión lineal

####POISSON
Observar:
- Overdispersion

*Duda: en el libro 'Statistics for biology and health' la overdisp. la calcula como residual deviance/df (pg. 224). Antonio pone que se calcula como sumatoria del cuadrado de los residuos de pearson del modelo / n - (nº parametros del modelo +1). Esto sería, para exergia por ejemplo:*
*Formula del libro: 3.8162/18 = 0.21*
*Formula Antonio: sumar cada residual de pearson al cuadrado calculado antes con 'resid(reg_exergia, type="pearson")^2' =4.20/18-(1+1)= 0.26*
*En los dos casos es menor que 1, se puede decir que no hay overdisp.?*
- AIC
*Duda: los AICs con Poisson son = Inf.*
- Var. explained (explained deviance)
*Explained deviance= (100x(null deviance-residual deviance))/null dev.*
- Coeficientes

**EXERGIA**
```{r, fig.show='asis'}
cor(COPLAS_INSTAR$avg_exergia, COPLAS_INSTAR$GRADO.REVISADO)
reg_exergia <- glm(COPLAS_INSTAR$avg_exergia ~ COPLAS_INSTAR$GRADO.REVISADO, family = poisson(link="log"))
summary.glm(reg_exergia)
```

*"The first two lines tell us which model has been fitted, which is handy if you save the output into a word processor document. Basic numerical information on the residuals is also provided, although in Section 9.8 we present more useful graphical tools that can be used for the model validation process. The estimated intercept and slope are 4.31 and –0.000106, respectively. Keep in mind that distance to the park is expressed in metres. To avoid parameter estimates with lots of zeros, you could (and perhaps should) express it in kilometres, as it will save some ink when presenting the estimated slope on paper. We also get a z-statistic and corresponding p-value for testing the null hypothesis that the slope (and intercept) is equal to 0 and an AIC, which can be used for model selection. The z-statistic is used because we know the variance. In a Gaussian model, the variance is estimated as well, and therefore, a t-statistic is used."*
*"The smaller the residual deviance, the better is the model."*

```{r, fig.show='asis'}
#Mirar overdispersion = residual deviance/df
3.8162/18
##Pearson residuals
(resid(reg_exergia, type="pearson"))^2
(1.51+0.79+0.58+0.003+0.34+0.091+0.41+0.08+0.001+0.01+0.0022+0.003+0.09+0.049+0.149+0.0057+0.067+0.011+0.0021+0.0015) / (18 - (1+1))=0.26

#Mirar explained deviance
(100*(3.8163-3.8162))/3.8163

#AIC
AIC(reg_exergia)
```

```{r}
plot(COPLAS_INSTAR$avg_exergia ~ COPLAS_INSTAR$GRADO.REVISADO, xlab="Grado de infestacion COPLAS", ylab = "Exergia rodal")
plot(reg_exergia)
dev.off()
```


**L1**
```{r}
cor(COPLAS_INSTAR$sum_l1, COPLAS_INSTAR$GRADO.REVISADO)
reg_L1 <- glm(COPLAS_INSTAR$sum_l1 ~ COPLAS_INSTAR$GRADO.REVISADO, family = poisson(link="log"))
summary.glm(reg_L1)
#Mirar overdispersion
49182818/18 
##
 
```
Sea cual sea la formula que se use va a salir un valor **MUY ALTO**. Decimos que hay overdisp.?? Hacemos quasipoisson:
```{r}
reg_L1_qpois <- glm(COPLAS_INSTAR$sum_l1 ~ COPLAS_INSTAR$GRADO.REVISADO, family = quasipoisson)
summary(reg_L1_qpois)
```
Da una dispersion de 2178478 ¿¿??
*"The dispersion parameter φ is estimated as 2178478. This means that all standard errors have been multiplied by 1476 (the square root of 2178478), and as a result, most parameters are no longer significant!"*

```{r}
#Mirar explained deviance
(100*(53589882-49182818))/53589882#=8.223687
#AIC
AIC(reg_L1_qpois)#NA

#plots
plot(COPLAS_INSTAR$sum_l1 ~ COPLAS_INSTAR$GRADO.REVISADO, xlab="Grado de infestacion COPLAS", ylab = "Suma L1 en el rodal")
plot(reg_L1_qpois)
dev.off()
```

**L2**
```{r}
cor(COPLAS_INSTAR$sum_l2, COPLAS_INSTAR$GRADO.REVISADO)
reg_L2 <- glm(COPLAS_INSTAR$sum_l2 ~ COPLAS_INSTAR$GRADO.REVISADO, family = poisson(link="log"))
summary.glm(reg_L2)
#Mirar overdispersion
26968257/18 

reg_L2_qpois <- glm(COPLAS_INSTAR$sum_l2 ~ COPLAS_INSTAR$GRADO.REVISADO, family = quasipoisson)
summary.glm(reg_L2_qpois)
#Dispersion segun quasipoison=1402424

#Mirar explained deviance
(100*(26968257-29317185))/26968257#=-8.709973
#AIC
AIC(reg_L2_qpois)#NA

#plots
plot(COPLAS_INSTAR$sum_l2 ~ COPLAS_INSTAR$GRADO.REVISADO, xlab="Grado de infestacion COPLAS", ylab = "Suma L2 en el rodal")
plot(reg_L2_qpois)
dev.off()

```


**L1+L2**
```{r}
cor(COPLAS_INSTAR$sum_l1l2, COPLAS_INSTAR$GRADO.REVISADO)
reg_L1L2 <- glm(COPLAS_INSTAR$sum_l1l2 ~ COPLAS_INSTAR$GRADO.REVISADO, family = poisson(link="log"))
summary.glm(reg_L1L2)
#Mirar overdispersion
71354778/18 

reg_L1L2_qpois <- glm(COPLAS_INSTAR$sum_l1l2 ~ COPLAS_INSTAR$GRADO.REVISADO, family = quasipoisson)
summary.glm(reg_L1L2_qpois)
#Dispersion segun quasipoison=3468083

#Mirar explained deviance
(100*(71354778-78035661))/71354778#=-8.709973
#AIC
AIC(reg_L!L2_qpois)#NA

#plots
plot(COPLAS_INSTAR$sum_l1l2 ~ COPLAS_INSTAR$GRADO.REVISADO, xlab="Grado de infestacion COPLAS", ylab = "Suma L1 y L2 en el rodal")
plot(reg_L1L2_qpois)
dev.off()
```


####NEGATIVE BINOMIAL

```{r}

```

#####ZEROINFLATED




### Residuos estandarizados
residuals<-rstandard(reg_exergia)
### Valores ajustados
fitted_values<-fitted(reg_exergia)
### Grafica valores ajustados vs residuos (asi evaluamos a ojo la homocedasticidad. Esto es discutible...)
plot(fitted_values, residuals)
### Grafico QQ para evaluar la normalidad
qqnorm(residuals)
qqline(residuals)
ggplot(COPLAS_INSTAR, aes(x=GRADO.REVISADO, y=avg_exergia))+
geom_point(colour='red', size=6) +
geom_smooth(method=lm)+
xlab("Grado infectacion COPLAS")+
ylab("Exergia media rodal")
```


# VALIDACION INTERNA

##ACP
Autocorrelation plot. 
Nos ayudara a saber si existen ciclos dentro de toda la serie temporal. 
ESTE ANALISIS SOLO SE HACE CON LOS DATOS DE BAZA

"*Those plots are showing you the correlation of the series with itself, lagged by x time unitscorrelation of the series with itself, lagged by x time units. So imagine taking your time series of length TT, copying it, and deleting the first observation of copy#1 and the last observation of copy#2. Now you have two series of length T−1T−1 for which you calculate a correlation coefficient. This is the value of of the vertical axis at x=1x=1 in your plots. It represents the correlation of the series lagged by one time unit. You go on and do this for all possible time lags xx and this defines the plot*.

*The answer to your question of what is needed to report a pattern is dependent on what pattern you would like to report. But quantitatively speaking, you have exactly what I just described: the correlation coefficient at different lags of the series. You can extract these numerical values by issuing the command  acf(x.ts,100)$acf*.

*In terms of what lag to use, this is again a matter of context. It is often the case that there will be specific lags of interest. Say, for example, you may believe the fish species migrates to and from an area every ~30 days. This may lead you to hypothesize a correlation in the time series at lags of 30. In this case, you would have support for your hypothesis*"

"*The blue lines give the values beyond which the autocorrelations are (statistically) significantly different from zero*" 

Hay que definir el LAG. lag.max= 

Primero he probado creando una serie temporal de la variable y luego aplicandole el ACF, y por otro lado he aplicado el ACF sin antes crear la ts. Sale lo mismo...
```{r, , fig.show='asis'}
exergia_ts_y<-ts(agreg_INSTAR_biociclo$avg_exergia, frequency = 1)
exergia_acf_y<-acf(exergia_ts_y, type=c("correlation"), plot=TRUE, lag.max = 19)
L1_ts_y<-ts(agreg_INSTAR_biociclo$sum_l1, frequency = 1)
L1_acf_y<-acf(L1_ts_y, type=c("correlation"), plot=TRUE, lag.max = 19)
```

```{r, fig.show='asis'}
huevo_acf<-acf(INSTAR$huevo, type=c("correlation"), plot=TRUE)
L1_acf<-acf(INSTAR$L1, type=c("correlation"), plot=TRUE)
L2_acf<-acf(INSTAR$L2, type=c("correlation"), plot=TRUE)
crisalida_acf<-acf(INSTAR$crisalida, type=c("correlation"), plot=TRUE)
exergia_acf<-acf(INSTAR$exergia, type=c("correlation"), plot=TRUE)
```
El dato de un año esta muy correlacionado con el año anterior
##Analisis de tendencia
Se eligen indicadores de cada variable para calcular su tendencia.
En las variables huevo, L1, L2 y crisalida:
- fecha del maximo.
- Fecha en la que aparece la variable (primer dia en el que la variable es distinta a cero).
En la variable exergia:
- fecha del maximo
- fecha del mínimo. 

*Nota: se puede calcular el minimo sin contar el 0?
*Dudas:
- una vez hecha la regresion, como se calcula la tendencia?
- hacer por año natural o por biocilo? BIOCICLO
```{r, fig.show='asis'}
max_huevo<-aggregate(x = INSTAR$huevo, by=list(year=INSTAR$biociclo), FUN=max, na.rm=TRUE)
names(max_huevo)[2] <- "max_huevo"
tend_huevo<-lm(max_huevo)
summary(tend_huevo)
plot(max_huevo)
abline(tend_huevo)#No se crea la la recta de regresion?
dev.off()
max_L1<-aggregate(x = INSTAR$L1, by=list(year=INSTAR$year), FUN=max, na.rm=TRUE)
names(max_L1)[2] <- "max_L1"
tend_L1<-lm(max_L1)
summary(tend_L1)
plot(max_L1)
abline(tend_L1)
dev.off()

max_L2<-aggregate(x = INSTAR$L2, by=list(year=INSTAR$year), FUN=max, na.rm=TRUE)
names(max_L2)[2] <- "max_L2"
tend_L2<-lm(max_L2)
summary(tend_L2)
plot(max_L2)
abline(tend_L2)
dev.off()

max_crisalida<-aggregate(x = INSTAR$crisalida, by=list(year=INSTAR$year), FUN=max, na.rm=TRUE)
names(max_crisalida)[2] <- "max_crisalida"
tend_crisalida<-lm(max_crisalida)
summary(tend_crisalida)
plot(max_crisalida)
abline(tend_crisalida)
dev.off()

max_exergia<-aggregate(x = INSTAR$exergia, by=list(year=INSTAR$year), FUN=max, na.rm=TRUE)
names(max_exergia)[2] <- "max_exergia"
tend_exergia_mx<-lm(max_exergia)
summary(tend_exergia_mx)
plot(max_exergia)
abline(tend_exergia_mx)
dev.off()

min_exergia<-aggregate(x = INSTAR$exergia, by=list(year=INSTAR$year), FUN=min, na.rm=TRUE)
names(min_exergia)[2] <- "min_exergia"
tend_exergia_mn<-lm(min_exergia)
summary(tend_exergia_mn)
plot(min_exergia)
abline(tend_exergia_mn)
dev.off()
```


## Definir ts: huevos, l1, l2, crisalidas, energia, tmax, tmin, tmedia
Esto por ahora no sirve. 
```{r}
plaga_ts<-ts(INSTAR[2:5], class=c("mts"), frequency=365)#Frecuencia es igual al numero de dias?
temp_ts<-ts(INSTAR[7:9], class=c("mts"), frequency=365)
huevos_ts<-ts(INSTAR$huevo, frequency=365)
L1_ts<-ts(INSTAR$L1, frequency=365)
L2_ts<-ts(INSTAR$L2, frequency=365)
crisalidas_ts<-ts(INSTAR$crisalida, frequency=1)
exergia_ts<-ts(INSTAR$exergia, frequency=1)
tmax_ts<-ts(INSTAR$tmax, frequency=1)
tmin_ts<-ts(INSTAR$tmin, frequency=1)
tmed_ts<-ts(INSTAR$tmed, frequency=1)
```

```{r}
summary(plaga_ts)
cycle (plaga_ts)
class(plaga_ts)
str(plaga_ts)
decompose(plaga_ts)
plot(decompose(plaga_ts))
```


NOTA: se supone que hay alguna manera de escribir el Markdown de manera que al verlo desde Github se vean las graficas o los resultados de la ejecucion. Esto estaria muy bien para poder ver los resultados de las regresiones de un vistazo y comparar entre ejecuciones. Seguro que Antonio sabe como se hace, el viernes le preguntamos :D